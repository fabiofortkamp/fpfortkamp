[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi there. I’m Dr. Fábio P. Fortkamp, I scientific software developer from southern Brazil.and in this blog I write about solving real Mechanical Engineering problems with Python, R, and other cool computational tools and apps."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education:",
    "text": "Education:\nDoctorate (Dr. Eng.) in Mechanical Engineering Federal University of Santa Catarina, 2019\nMaster’s (M. Eng.) in Mechanical Engineering Federal University of Santa Catarina, 2014\nBachelor in Mechanical Engineering Federal University of Santa Catarina, 2012"
  },
  {
    "objectID": "about.html#research-and-professional-interests",
    "href": "about.html#research-and-professional-interests",
    "title": "About",
    "section": "Research and professional interests",
    "text": "Research and professional interests\n\nMagnetocaloric Refrigeration\nMachine Learning\nMixture Thermodynamics\nMultiphysics Problems\nMultiphase Heat Transfer"
  },
  {
    "objectID": "posts/2022-03-14-isothermic/index.html",
    "href": "posts/2022-03-14-isothermic/index.html",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "",
    "text": "In the previous post, we saw how to calculate the speed of sound of a mixture of ideal gases, the main assumption is that we can add the individual specific heats of the components, weighted by the mass fractions.\nFor mixtures of ideal gases, this is true for all mass-specific properties, including the gas constant \\(R\\). Hence, basic First-Law analyses can be performed quite easily."
  },
  {
    "objectID": "posts/2022-03-14-isothermic/index.html#an-example-of-isothermic-work",
    "href": "posts/2022-03-14-isothermic/index.html#an-example-of-isothermic-work",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "An example of isothermic work",
    "text": "An example of isothermic work\nThe specific work required to compress an ideal gas in a closed system [1] isothermally at \\(T\\) from pressure \\(P_1\\) to \\(P_2\\) is [1]:\n\\[\nw_{\\mathrm{comp}} = R T \\ln \\frac{P_2}{P_1}\n\\]\nThis is also valid for a mixture of ideal gases, provided the mixture gas constant is used:\n\\[\nR = \\frac{R_u}{M_{\\mathrm{m}}}\n\\]\nwhere \\(R_u = 8.31447\\,\\mathrm{kJ/kg K}\\) is the universal gas constant and the mixture molar mass is:\n\\[\nM_{\\mathrm{m}} = \\sum_{i=1}^k y_i M_i\n\\]\nsumming over \\(k\\) components, and there \\(y_i\\) and \\(M_i\\) are the individual molar fractions and molar mass of component \\(i\\), respectively.\nConsider exercise 13-94 from [1]: the mixture contains 85% of nitrogen gas, and the remainder is carbon dioxide. The temperature is held at 300 K and the pressure is risen from 100 kPa to 500 kPa. What is the compression work?\nThe following implementation is in R. We first define a function to compute the desired value based on the initial content of nitrogen:\n\nwork.N2.CO2 &lt;- function(yN2) {\n  MN2 &lt;- 28.013\n  MCO2 &lt;- 44.01\n  Ru &lt;-  8.13447\n  T &lt;- 300\n  P1 &lt;- 100\n  P2 &lt;- 500\n  \n  Mm &lt;- yN2*MN2 + (1-yN2)*MCO2\n  R = Ru/Mm\n  \n  wcomp &lt;- R*T*log(P2/P1)\n  wcomp\n}\n\nLet’s check with the individual given value:\n\nprint(work.N2.CO2(0.85))\n\n[1] 129.1433\n\n\nNotice that this value is in kJ/kg.\nNow, let’s see how this varies with nitrogen content:\n\ncurve(work.N2.CO2,from=0,to=1)\n\n\n\n\n\n\n\n\nThe more nitrogen we have, the larger the work. Why is that? Nitrogen is lighter (compare the molar masses), so with more nitrogen the mixture molar mass decreases, but that increases the gas constant and hence the specific work. The overall volume variations increase with a lighter gas, increasing the required work to increase the pressure."
  },
  {
    "objectID": "posts/2022-03-14-isothermic/index.html#an-example-of-isentropic-work",
    "href": "posts/2022-03-14-isothermic/index.html#an-example-of-isentropic-work",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "An example of isentropic work",
    "text": "An example of isentropic work\nNow we examine Exercise 13-95 from [1], where are given directly the mixture molar mass of 32 kg/kmol and a specific heat ratio of 1.35; as we’ve discussed, these are obtained from weighted sums. The initial state is 100 kPa and 293 K, the final pressure 1000 kPa, and the process occurs at constant entropy. What is the work?\nThe compression work of an ideal gas in an isentropic process is:\n\\[\nw_{\\mathrm{comp}} = \\frac{R T_1}{k-1} \\left[\\left(\\frac{P_2}{P_1}\\right)^{{\\frac{k-1}{k}}}-1\\right]\n\\] Can we use this expression of a single ideal gas for a mixture of ideal gases? Again yes, provide we use the mixture properties, which are already given. Notice that the mixture gas constant is not given but can be calculated similarly as above. Hence:\n\nk &lt;-  1.35\nMm &lt;- 32\nRu &lt;-  8.13447\nR &lt;- Ru/Mm \n\nP1 &lt;- 100\nP2 &lt;- 1000\nT1 &lt;- 293\n\n# some intermediate parameters to facilitate writing\nPi = P2/P1\ngamma = ((k-1)/k)\nY = Pi^gamma - 1\n\nwcomp &lt;- (R*T1)/(k-1) * Y\nprint(wcomp) # in kJ/kg\n\n[1] 173.7753\n\n\nTo compare, we can also compute the work by temperature variations. An isentropic process follows \\[\n\\frac{T_2}{T_1} = \\left(\\frac{P_2}{P_1}\\right)^{\\frac{k-1}{k}}\n\\]\nand, in an adiabatic closed-system process:\n\\[\nw_{\\mathrm{comp}} = c_v(T_2-T_1)\n\\]\nwhere \\(c_v = \\frac{R}{k-1}\\).\n\nk &lt;-  1.35\nMm &lt;- 32\nRu &lt;-  8.13447\nR &lt;- Ru/Mm \n\nP1 &lt;- 100\nP2 &lt;- 1000\nT1 &lt;- 293\n\nT2 &lt;- T1*(P2/P1)^((k-1)/k)\ncv &lt;- R/(k-1)\nwcomp &lt;- cv*(T2-T1)\nprint(wcomp)\n\n[1] 173.7753\n\n\nAnd the values match."
  },
  {
    "objectID": "posts/2022-03-14-isothermic/index.html#references",
    "href": "posts/2022-03-14-isothermic/index.html#references",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "References",
    "text": "References\n[1]: Çengel, Y. A., & Boles, M. A. Termodinâmica (7 ed.). Porto Alegre: AMGH, 2013. In Portuguese."
  },
  {
    "objectID": "posts/2022-02-27-what-is-this-site/index.html",
    "href": "posts/2022-02-27-what-is-this-site/index.html",
    "title": "What is this site",
    "section": "",
    "text": "Hi there. I’m Fábio Fortkamp, a Professor of Mechanical Engineering from Brazil. This is my academic website, where I post explorations in Thermal Engineering, R, Python, and Mechanical Engineering in general.\nThis site is my attempt to more properly show my work. As I study, prepare for lectures, and develop my research, I will try to post my discoveries here. In particular, at least in this stage, I will focus on solving problems on Thermodynamics, Heat Transfer, Heat Engines, Refrigeration Systems using computational tools. Python and R are the main tools I use; my mission is to make the next generation of Engineers more apt to solve real-life problems with data science and programming concepts. More exploration, and less memorization.\nThanks in advance for reading."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fábio P. Fortkamp’s website",
    "section": "",
    "text": "Higher productivity for developers with Starship\n\n\n\n\n\n\nblog\n\n\n\n\n\n\n\n\n\nApr 8, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nSoftware Development Book Review: Writing Interpreters in Go\n\n\n\n\n\n\nbook-recommendations\n\n\nlearning-interpreters-and-compilers\n\n\n\n\n\n\n\n\n\nApr 5, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nStudying Go to get better at Python: reader and writer interfaces\n\n\n\n\n\n\nblog\n\n\n\n\n\n\n\n\n\nApr 4, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nHow to make Neovim Python LSP aware of your Hatch environments\n\n\n\n\n\n\narticles\n\n\nconfiguring-neovim-for-maximum-productivity\n\n\n\n\n\n\n\n\n\nMar 19, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWhy I’m studying how to write an interpreter in Go… when I’m a Python developer\n\n\n\n\n\n\narticles\n\n\nbook-recommendations\n\n\nlearning-interpreters-and-compilers\n\n\nwhat-im-studying\n\n\n\n\n\n\n\n\n\nMar 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nWhy and how to use different colors in VS Code for different projects\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nDec 21, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nI’m a Python developer - and this is why I’m learning Julia\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nDec 13, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nWhy a mechanical engineer uses Linux - in Windows\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nDec 2, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nCompressibility and Expandability: what are they and how to calculate\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nNov 10, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nStages of studying: 1 - Inspectional Reading\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nNov 9, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\n3 things missing from the Mechanical Engineering curriculum\n\n\n\n\n\n\nLists\n\n\n\n\n\n\n\n\n\nNov 8, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nIncluding superheat in the compressor regression\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nApr 20, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nExploring and regressing data from a compressor datasheet with Python\n\n\n\n\n\n\nArticles\n\n\n\n\n\n\n\n\n\nApr 19, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst Law Analysis of a Mixture of Non-Ideal Gases - Exercise 13-99 from Çengel's Thermodynamics book (7th ed)\n\n\n \n\n\nExercise from Çengel's Thermodynamics\n\n\n \n\n\n\n\n\n`Mar 18, 2022`{=html}\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculting equilibrium composition of a mixture of gases - Exercise 16-89 from Çengel's Thermodynamics book (7th ed)\n\n\n \n\n\nExercise from Çengel's Thermodynamics\n\n\n \n\n\n\n\n\n`Mar 17, 2022`{=html}\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst Law Analysis of a Mixture of Ideal Gases - Exercise 13-97 from Çengel's Thermodynamics book (7th ed)\n\n\n \n\n\nExercise from Çengel's Thermodynamics\n\n\n \n\n\n\n\n\n`Mar 15, 2022`{=html}\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComputing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel's Thermodynamics book\n\n\n \n\n\nExercise from Çengel's Thermodynamics\n\n\n \n\n\n\n\n\n`Mar 15, 2022`{=html}\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpeed of sound of a mixture of gases - Exercise 13-92 from Çengel's Thermodynamics book (7th ed)\n\n\n \n\n\nExercise from Çengel's Thermodynamics\n\n\n \n\n\n\n\n\n`Mar 14, 2022`{=html}\nFábio P. Fortkamp\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is this site\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\n\n\n\nFeb 27, 2022\n\n\nFábio P. Fortkamp\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "post/mixture/index.html",
    "href": "post/mixture/index.html",
    "title": "Speed of sound of a mixture of gases - Exercise 13-92 from Çengel’s Thermodynamics book (7th ed)",
    "section": "",
    "text": "Why do we need a separate mixture thermodynamics subject? Because, when two fluids are mixed, the individual properties do not necessarily add up to the total system, due to interaction effects.\nAs usual in Thermodynamics, we need a reference model, and the ideal model for mixtures is an ideal gas mixture, where certain properties are simply the weighted sum of the properties of the components."
  },
  {
    "objectID": "post/mixture/index.html#calculating-the-speed-of-sound-of-a-mixture-of-ideal-gases",
    "href": "post/mixture/index.html#calculating-the-speed-of-sound-of-a-mixture-of-ideal-gases",
    "title": "Speed of sound of a mixture of gases - Exercise 13-92 from Çengel’s Thermodynamics book (7th ed)",
    "section": "Calculating the speed of sound of a mixture of ideal gases",
    "text": "Calculating the speed of sound of a mixture of ideal gases\nAs an example, let’s us solve Exercise 13-92 from [1]: a mixture of carbon dioxide and nitrogen flows through a convergent nozzle, and it exits at 500 K and a speed of 360 m/s, which is stated as the speed of sound of the mixture in that condition. What is the mass fraction of carbon dioxide in this mixture?\nFirst, some context. Carbon dioxide and nitrogen are common combustion products: gases that are formed when hydrocarbons burn with air. Other compounds are formed, such as water vapor, sulfur oxides and excess oxygen, but depending on the fuel composition and air context, carbon dioxide and nitrogen dominate the gases, and we approximate the combustion gas as a mixture of just these two gases. Convergent nozzles are commonly employed in airplane jet turbines to accelerate the fluid (the combustion gases) and generate thrust.\nLet \\(x_{\\mathrm{CO_2}}\\) be the mass fraction of carbon dioxide in the mixture, and hence \\(x_{\\mathrm{N_2}} = 1 - x_{\\mathrm{CO_2}}\\).\nWe’ll assume both components are ideal gases in the problem’s conditions, and a mixture of ideal gases is itself an ideal gas. The speed of sound for these fluids is [1]:\n\\[\nc^2 = k R T\n\\]\nwhere \\(k\\) is the ratio of isobaric to isovolumetric specific heats, and \\(R\\) is the difference between then:\n\\[\nkR = \\frac{c_p}{c_v}\\left(c_p - c_v\\right)\n\\]\nNow, the specific heats is a property that is additive:\n\\[\nc_p = x_{\\mathrm{CO_2}}c_{p,\\mathrm{CO_2}} (T) + \\left(1-x_{\\mathrm{CO_2}}\\right)c_{p,\\mathrm{N_2}} (T)\n\\]\n\\[\nc_v = x_{\\mathrm{CO_2}}c_{v,\\mathrm{CO_2}} (T) + \\left(1-x_{\\mathrm{CO_2}}\\right)c_{v,\\mathrm{N_2}} (T)\n\\] where, since the temperature is fixed, the individual values of specific heats can be read from a table.\nIf the given speed is the speed of sound, then \\(V^2 = c^2  = kRT\\), and with some rearranging the following function will achieve a zero:\n\\[\nf(x_{\\mathrm{CO_2}}) = \\frac{V^2}{c_p T} - \\frac{c_p-c_v}{c_v}\n\\]"
  },
  {
    "objectID": "post/mixture/index.html#implementation",
    "href": "post/mixture/index.html#implementation",
    "title": "Speed of sound of a mixture of gases - Exercise 13-92 from Çengel’s Thermodynamics book (7th ed)",
    "section": "Implementation",
    "text": "Implementation\nThe following R code should defines the values, including some read from specific heat tables:\n\nT &lt;- 500\nV &lt;- 360\n# Values @ 500 K\nc_p_CO2 &lt;- 1.014e3\nc_v_CO2 &lt;- 0.825e3\nc_p_N2 &lt;- 1.056e3\nc_v_N2 &lt;- 0.759e3\n\nNow, we define the function to be zeroed:\n\nf &lt;- function(x) {\n  c_p &lt;-  x*c_p_CO2 + (1-x)*c_p_N2\n  c_v &lt;-  x*c_v_CO2 + (1-x)*c_v_N2\n  \n  V^2/(c_p*T) - (c_p - c_v)/c_v\n}\n\nA good first check is to see how this function behaves:\n\ncurve(f,from=0,to=1)\n\n\n\n\n\n\n\n\nThere is indeed a zero! Let’s find it; the following built-in function finds a zero in the given interval:\n\nx_CO2 &lt;- uniroot(f,c(0,1))\nprint(x_CO2)\n\n$root\n[1] 0.8359597\n\n$f.root\n[1] -1.041024e-06\n\n$iter\n[1] 3\n\n$init.it\n[1] NA\n\n$estim.prec\n[1] 6.103516e-05\n\n\nwhich gives the answer that a mixture of 83,6% of carbon dioxide and (100-83,6)% at 500 K will have a speed of sound of 360 m/s.\nYou see that basic assumption was adding up the specific heats, which is not valid always. For instance, in steam power plants, you have compressed steam flowing in the system; if you have air that infiltrate the pipes, you’ll have a mixture of steam and air, and at the typical high pressures of boilers the specific heat of this mixture will not be the sum of individual specific heats, weighted by the mass fractions. A more appropriate mixture rule will be required. The ideal gases model for combustion gases, tough, is widely used.\n[1]: Çengel, Y. A., & Boles, M. A. Termodinâmica (7 ed.). Porto Alegre: AMGH, 2013. In Portuguese"
  },
  {
    "objectID": "post/isothermic/index.html",
    "href": "post/isothermic/index.html",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "",
    "text": "In the previous post, we saw how to calculate the speed of sound of a mixture of ideal gases, the main assumption is that we can add the individual specific heats of the components, weighted by the mass fractions.\nFor mixtures of ideal gases, this is true for all mass-specific properties, including the gas constant \\(R\\). Hence, basic First-Law analyses can be performed quite easily."
  },
  {
    "objectID": "post/isothermic/index.html#an-example-of-isothermic-work",
    "href": "post/isothermic/index.html#an-example-of-isothermic-work",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "An example of isothermic work",
    "text": "An example of isothermic work\nThe specific work required to compress an ideal gas in a closed system [1] isothermally at \\(T\\) from pressure \\(P_1\\) to \\(P_2\\) is [1]:\n\\[\nw_{\\mathrm{comp}} = R T \\ln \\frac{P_2}{P_1}\n\\]\nThis is also valid for a mixture of ideal gases, provided the mixture gas constant is used:\n\\[\nR = \\frac{R_u}{M_{\\mathrm{m}}}\n\\]\nwhere \\(R_u = 8.31447\\,\\mathrm{kJ/kg K}\\) is the universal gas constant and the mixture molar mass is:\n\\[\nM_{\\mathrm{m}} = \\sum_{i=1}^k y_i M_i\n\\]\nsumming over \\(k\\) components, and there \\(y_i\\) and \\(M_i\\) are the individual molar fractions and molar mass of component \\(i\\), respectively.\nConsider exercise 13-94 from [1]: the mixture contains 85% of nitrogen gas, and the remainder is carbon dioxide. The temperature is held at 300 K and the pressure is risen from 100 kPa to 500 kPa. What is the compression work?\nThe following implementation is in R. We first define a function to compute the desired value based on the initial content of nitrogen:\n\nwork.N2.CO2 &lt;- function(yN2) {\n  MN2 &lt;- 28.013\n  MCO2 &lt;- 44.01\n  Ru &lt;-  8.13447\n  T &lt;- 300\n  P1 &lt;- 100\n  P2 &lt;- 500\n  \n  Mm &lt;- yN2*MN2 + (1-yN2)*MCO2\n  R = Ru/Mm\n  \n  wcomp &lt;- R*T*log(P2/P1)\n  wcomp\n}\n\nLet’s check with the individual given value:\n\nprint(work.N2.CO2(0.85))\n\n[1] 129.1433\n\n\nNotice that this value is in kJ/kg.\nNow, let’s see how this varies with nitrogen content:\n\ncurve(work.N2.CO2,from=0,to=1)\n\n\n\n\n\n\n\n\nThe more nitrogen we have, the larger the work. Why is that? Nitrogen is lighter (compare the molar masses), so with more nitrogen the mixture molar mass decreases, but that increases the gas constant and hence the specific work. The overall volume variations increase with a lighter gas, increasing the required work to increase the pressure."
  },
  {
    "objectID": "post/isothermic/index.html#an-example-of-isentropic-work",
    "href": "post/isothermic/index.html#an-example-of-isentropic-work",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "An example of isentropic work",
    "text": "An example of isentropic work\nNow we examine Exercise 13-95 from [1], where are given directly the mixture molar mass of 32 kg/kmol and a specific heat ratio of 1.35; as we’ve discussed, these are obtained from weighted sums. The initial state is 100 kPa and 293 K, the final pressure 1000 kPa, and the process occurs at constant entropy. What is the work?\nThe compression work of an ideal gas in an isentropic process is:\n\\[\nw_{\\mathrm{comp}} = \\frac{R T_1}{k-1} \\left[\\left(\\frac{P_2}{P_1}\\right)^{{\\frac{k-1}{k}}}-1\\right]\n\\] Can we use this expression of a single ideal gas for a mixture of ideal gases? Again yes, provide we use the mixture properties, which are already given. Notice that the mixture gas constant is not given but can be calculated similarly as above. Hence:\n\nk &lt;-  1.35\nMm &lt;- 32\nRu &lt;-  8.13447\nR &lt;- Ru/Mm \n\nP1 &lt;- 100\nP2 &lt;- 1000\nT1 &lt;- 293\n\n# some intermediate parameters to facilitate writing\nPi = P2/P1\ngamma = ((k-1)/k)\nY = Pi^gamma - 1\n\nwcomp &lt;- (R*T1)/(k-1) * Y\nprint(wcomp) # in kJ/kg\n\n[1] 173.7753\n\n\nTo compare, we can also compute the work by temperature variations. An isentropic process follows \\[\n\\frac{T_2}{T_1} = \\left(\\frac{P_2}{P_1}\\right)^{\\frac{k-1}{k}}\n\\]\nand, in an adiabatic closed-system process:\n\\[\nw_{\\mathrm{comp}} = c_v(T_2-T_1)\n\\]\nwhere \\(c_v = \\frac{R}{k-1}\\).\n\nk &lt;-  1.35\nMm &lt;- 32\nRu &lt;-  8.13447\nR &lt;- Ru/Mm \n\nP1 &lt;- 100\nP2 &lt;- 1000\nT1 &lt;- 293\n\nT2 &lt;- T1*(P2/P1)^((k-1)/k)\ncv &lt;- R/(k-1)\nwcomp &lt;- cv*(T2-T1)\nprint(wcomp)\n\n[1] 173.7753\n\n\nAnd the values match."
  },
  {
    "objectID": "post/isothermic/index.html#references",
    "href": "post/isothermic/index.html#references",
    "title": "Computing the work of a mixture of gases - Exercises 13-94 and 13-95 from Çengel’s Thermodynamics book",
    "section": "References",
    "text": "References\n[1]: Çengel, Y. A., & Boles, M. A. Termodinâmica (7 ed.). Porto Alegre: AMGH, 2013. In Portuguese."
  },
  {
    "objectID": "post/whats/index.html",
    "href": "post/whats/index.html",
    "title": "What is this site",
    "section": "",
    "text": "Hi there. I’m Fábio Fortkamp, a Professor of Mechanical Engineering from Brazil. This is my academic website, where I post explorations in Thermal Engineering, R, Python, and Mechanical Engineering in general.\nThis site is my attempt to more properly show my work. As I study, prepare for lectures, and develop my research, I will try to post my discoveries here. In particular, at least in this stage, I will focus on solving problems on Thermodynamics, Heat Transfer, Heat Engines, Refrigeration Systems using computational tools. Python and R are the main tools I use; my mission is to make the next generation of Engineers more apt to solve real-life problems with data science and programming concepts. More exploration, and less memorization.\nThanks in advance for reading."
  },
  {
    "objectID": "post/missing/index.html",
    "href": "post/missing/index.html",
    "title": "3 things missing from the Mechanical Engineering curriculum",
    "section": "",
    "text": "In 2020, I ended my post-doc position and started teaching Mechanical Engineering classes (in a different university). I loved the teaching experience, and I learned a lot. One month ago, however, in search of new challenges, I quit that job and got accepted at a research-only position, dealing directly with industry problems. And in only one month, I realized how much has to be changed in Mechanical Engineering curricula, to make it more modern and more aligned with practical, real problems. These are my suggestions:\n\nProper software development: Mechanical Engineering is not Computer Science. Maybe we don’t need to learn about Turing Machines, Cryptography, or Web Sockets. But my present job is the second time in my career that my primary role is implementing models in software to be used by other people, and I didn’t learn any software development in school. Students should learn more about testing, version control, different programming languages, debugging.\nMore advanced Thermodynamics: in retrospect, I think I severely underestimated my student’s ability to understand deep theories. The Refrigeration and Oil industries are primary examples where blends or mixtures of fluids are used, and in my experience students have no contact with more advanced Equations of State; there is an enormous gap between “using the ideal gas law” and “just getting the properties from a table”. But guess what: these tables are not magical, they were generated with Equations of State, and the people using them do not understand these equations.\nStudying techniques: I started teaching shortly after the pandemic; I then taught classes online, and went back to in-person classes. And what I saw is that the younger generation completely forgot how to study with full focus. I’m not talking about spending the entire weekend studying for an exam, but rather the Cal Newport style of deep work, in short but intense bursts.\n\nTo be clear: I’m not “fighting the system”. These are things that I would change if I went back to the classroom, in my own classes. Teaching Mechanical Engineering made me love the profession more than ever, and I want it to evolve - always.\nAny thoughts. Comment on Twitter or leave a note below!"
  },
  {
    "objectID": "post/first/index.html",
    "href": "post/first/index.html",
    "title": "First Law Analysis of a Mixture of Ideal Gases - Exercise 13-97 from Çengel’s Thermodynamics book (7th ed)",
    "section": "",
    "text": "This is exercise 13-97 from [1]: a mixture of gases composed of 55% of nitrogen gas and 45% of carbon dioxide (in mass) is originally at 200 kPa and 45 ˚C. The system is heated up and expands, but due to the action of a spring, the pressure variation as a function of volume \\(P(\\mathcal{V})\\) follows:\n\\[\nP = A + K \\mathcal{V}\n\\] where \\(A = 111.111\\,\\mathrm{kPa}\\) and \\(K = 888.89\\,\\mathrm{kPa/m^3}\\). During the heating, volume doubles; what is the work and heat transfers associated with the process?\nFor that, in contrast with the previous posts, now we’ll use Python and the pyromat package, which I’ve just discovered today.\nWith the added heat, the system will expand and perform work, which can be calculated using only mechanics:\n\\[\nW = \\int_{\\mathcal{V}_1}^{\\mathcal{V}_2} P \\mathrm{d}\\mathcal{V}\n\\]\nWhere the initial volume can be obtained from the given pressure variation, and the final volume is double that:\nA = 111.111\nK = 888.89\n\nP1 = 200\nV1 = (P1-A)/K\nprint(\"V1 = %.2f m3\" %(V1))\nV2 = 2*V1\n\nV1 = 0.10 m3\nThe integration above gives:\n\\[\nW = A * (\\mathcal{V}_2 - \\mathcal{V}_1) + \\frac{K}{2}\\left(\\mathcal{V}_2^2 - \\mathcal{V}_1^2\\right)\n\\]\nand calculating it:\nW = A*(V2-V1) + K/2*(V2**2 - V1**2)\nprint(\"W = %.2f kJ\" %(W,))\n\nW = 24.44 kJ\nTo compute the heat added to the system, a First Law analysis reads:\n\\[\nQ = W + \\Delta U = W + m c_v (T_2-T_1)\n\\]\nwhere, assuming a mixture of ideal gases (an hypothesis not used so far!), all mass-specific properties are additive. The gas constant is:\n\\[\nR = \\sum_{i=1}^k x_i R_i\n\\] where \\(k = 2\\) components, \\(x_i\\) is the individual mass fraction and \\(R_i\\) the individual gas constant. The gas constant is needed to compute the temperature variation; at state 1, the mass (which is constant in all states for a closed system) is computed from the ideal gas equation of state:\n\\[\nm = \\frac{P_1 V_1}{R T_1}\n\\]\nand now, applying the same equation for state 2:\n\\[\nT_2 = \\frac{P_2 V_2}{m R}\n\\]\nwhere \\(P_2\\) can be obtained from the pressure-volume equation.\nThe constant-volume specific heat for ideal gases is a function of temperature only, and for better accuracy can be calculated at the average temperature. The mixture specific heat is computed similarly to the gas constant above.\nThe pyromat library has function to create ideal gas “objects” and then access constants and functions as illustrated below:\nimport pyromat as pm\nN2 = pm.get(\"ig.N2\") # ig = ideal gas model\nCO2 = pm.get(\"ig.CO2\")\n\nxN2 = 0.55\nxCO2 = 1-xN2\n\n# each object has a .R() method to calculate the gas constant\n# the default units are kJ, kPa, m3, K, kmol\nR = xN2*N2.R() + xCO2*CO2.R()\n\nT1 = 45 + 273\nm = (P1*V1)/(R*T1)\n\nP2 = A + K*V2\nT2 = (P2*V2)/(m*R)\n\nTmean = (T1 + T2)/2\n\ncv = xN2*N2.cv(T=Tmean) + xCO2*CO2.cv(T=Tmean)\n\nQ = W + m*cv*(T2-T1)\nprint(\"Q = %.2f kJ\" %(Q,))\n\nQ = 151.26 kJ\n\n\n/tmp/ipykernel_205294/1406596206.py:23: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  print(\"Q = %.2f kJ\" %(Q,))"
  },
  {
    "objectID": "post/first/index.html#references",
    "href": "post/first/index.html#references",
    "title": "First Law Analysis of a Mixture of Ideal Gases - Exercise 13-97 from Çengel’s Thermodynamics book (7th ed)",
    "section": "References",
    "text": "References\n[1]: Çengel, Y. A., & Boles, M. A. Termodinâmica (7 ed.). Porto Alegre: AMGH, 2013."
  },
  {
    "objectID": "post/inspectional/index.html",
    "href": "post/inspectional/index.html",
    "title": "Stages of studying: 1 - Inspectional Reading",
    "section": "",
    "text": "Adler and Van Doren’s How to Read a Book is one of the my favorite books. Although the authors talk about “normal” books (fiction, non-fiction, poetry), I think most of its teachings apply to textbooks and other materials to study in an academic sense.\nThis is the first in a series of posts detailing how I study hard materials and try to extract the most knowledge from them."
  },
  {
    "objectID": "post/inspectional/index.html#studying-in-stages",
    "href": "post/inspectional/index.html#studying-in-stages",
    "title": "Stages of studying: 1 - Inspectional Reading",
    "section": "Studying in stages",
    "text": "Studying in stages\nThe basic premise of the book, and something that I apply to almost everything I read, is that reading or studying should be done in stages. I felt quite at home when Adler and van Doren talk about the classic error of trying to read a difficult book, stumping into the first hard concept, and then being stuck for hours in the same chapter - without even understanding what the book is about. Depending on the book level, you will not understand it in the first reading.\nHence, when you have anything to read in front of you, the first step is to do an Inspectional Reading - a high-level form of reading, aiming for general concepts and the overall structure of the book or document, without wasting time on details."
  },
  {
    "objectID": "post/inspectional/index.html#what-to-look-when-inspectional-reading",
    "href": "post/inspectional/index.html#what-to-look-when-inspectional-reading",
    "title": "Stages of studying: 1 - Inspectional Reading",
    "section": "What to look when inspectional reading",
    "text": "What to look when inspectional reading\nThe authors of How to Read a Book make it clear: inspectional reading is active and demand you take notes. Lately I’ve been a fan of taking notes in paper notebooks:\n\n\n\nPhoto of a notebook with notes titles “Inspectional Reading”\n\n\nNotice above what I noted: the overall structure of a Heat Transfer book I was studying, the main themes threated, some comments on the notation used, the main equations that grabbed my attention, and then some tasks to delve deeper.\nWhen I was reading the material above, did I encounter some concepts that I did not understand? Of course! But I did not let it stop me of skimming through the whole book. I was actually looking for some details about differential equations, and I have to say I do not understand them yet – but I do know that this book has some answers, and I know where to look. I need another deep work session to do an analytical reading - subject of another post."
  },
  {
    "objectID": "post/inspectional/index.html#time-constraints",
    "href": "post/inspectional/index.html#time-constraints",
    "title": "Stages of studying: 1 - Inspectional Reading",
    "section": "Time constraints",
    "text": "Time constraints\nIt is fundamental that an inspectional reading is time bounded - an hour, at most. The purpose of this stage is to get answers quickly and not waste time\nHere is another example when I was studying some old class notes:\n\n\n\nPhoto of notebook with notes\n\n\nI was examining these class notes because my father made me take all of my old college notebooks from his home, and while studying the Heat Transfer book I remember of a Linear Systems class that I took in college.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nView this post on Instagram\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA post shared by Fábio P. Fortkamp, Dr. Eng. | Mechanical Engineer (@fpfortkamp)\n\n\n\n\nI thought studying these notes might be useful for my projects - but as I completed my Inspectional Reading, I realized this material was not right (for now). I did not have to read two chapters in detail, which would take much more time, to reach that conclusion."
  },
  {
    "objectID": "post/inspectional/index.html#the-other-stages",
    "href": "post/inspectional/index.html#the-other-stages",
    "title": "Stages of studying: 1 - Inspectional Reading",
    "section": "The other stages",
    "text": "The other stages\nStudying is deeply important to me as a researcher, and I treat it seriously. I can only advance in my carrer if I have impactful ideas.\n{{&lt; tweet 1589653650598924289 &gt;}}\nStay tuned for more posts of my study techniques and tips…"
  },
  {
    "objectID": "post/superheat/index.html",
    "href": "post/superheat/index.html",
    "title": "Including superheat in the compressor regression",
    "section": "",
    "text": "We are always learning. After studying more about compressor datasheets, I realized that I forgot to include the superheat in yesterday’s post. Let’s fix that.\nThe main problem is that, in every calculation, I took the inlet state as saturated vapor in the given evaporating temperature, when in reality the datasheet specifies that the vapor always enters at 32.2 ºC.\nSo let’s start again. We will read the dataset with pandas:\nimport pandas as pd\n\ndf = pd.read_csv(\"compressor.csv\",delimiter=',')\nprint(df)\n\n   Evaporating Temperature [C]  Condensing temperature [C]  \\\n0                          -35                          35   \n1                          -30                          35   \n2                          -25                          35   \n3                          -20                          35   \n4                          -15                          35   \n5                          -10                          35   \n\n   Cooling Capacity [W]  Power [W]  Current [A]  Gas Flow Rate [kg/h]  \\\n0                   167        129         1.21                  1.79   \n1                   218        144         1.23                  2.34   \n2                   282        160         1.27                  3.03   \n3                   362        177         1.32                  3.89   \n4                   457        197         1.38                  4.93   \n5                   570        217         1.45                  6.16   \n\n    Efficiency [W/W]  \n0               1.29  \n1               1.52  \n2               1.77  \n3               2.04  \n4               2.33  \n5               2.63\nThe sections below are mostly a repetition, but we’ll update the equations where necessary:"
  },
  {
    "objectID": "post/superheat/index.html#how-to-calculate-the-mass-flow-rate-of-a-compressor",
    "href": "post/superheat/index.html#how-to-calculate-the-mass-flow-rate-of-a-compressor",
    "title": "Including superheat in the compressor regression",
    "section": "How to calculate the mass flow rate of a compressor?",
    "text": "How to calculate the mass flow rate of a compressor?\nA reciprocating compressor like this one is a volumetric machine: it displaces a certain volume of fluid, based on its internal geometry, and the mass flow rate depends on the suction state.\nThe most basic, ideal model is then:\n\\[\n\\dot{m} = \\frac{\\dot{\\mathcal{V}} _{\\mathrm{D}}}{v _{\\mathrm{in}}}\n\\]\nwhere the numerator is the displacement rate; for a compressor with \\(z\\) cylinders at a fixed rotation speed \\(n\\) it can be calculated\n\\[\n\\dot{\\mathcal{V}} _{\\mathrm{D}} = {\\mathcal{V}} _{\\mathrm{D}} n z\n\\]\nwhere \\(\\mathcal{V} _{\\mathrm{D}}\\) is the internal displacement.\nLet’s plot the actual mass flow rate from the datasheet (using the geometric parameters from it) and the above model to compare:\n\nimport matplotlib.pyplot as plt\nfrom CoolProp.CoolProp import PropsSI\nimport numpy as np\n\nplt.rc('font', size=12)\n\nVd = 13.54e-6 # in m3\nn = 60 #Hz\nz = 1\nfluid = 'R600a'\nTreturn = 32.2 + 273\n\nVd_dot = Vd * n * z # m3/s\nT_evap = df[\"Evaporating Temperature [C]\"].values\nm_dot_actual = df[\"Gas Flow Rate [kg/h]\"].values\n\n# we take the inverse of the density \n# of the vapor at the evaporing *pressure*\n# and the return gas temperature\nv_in = np.array([(1.0/PropsSI(\"D\",\"T\",Treturn,\"P\",PropsSI(\"P\",\"T\",Te+273,\"Q\",1,fluid),fluid)) for Te in T_evap])\nm_dot_ideal = 3600*Vd_dot/v_in\n\nfig, ax = plt.subplots()\nax.plot(T_evap,m_dot_ideal,'k-',label=\"Ideal\")\nax.plot(T_evap,m_dot_actual,'ko',label=\"Actual\")\nax.set_xlabel(\"Evaporating temperature [ºC]\")\nax.set_ylabel(\"Gas flow rate [kg/h]\")\nax.legend()\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n\nClearly our model is not good enough! There is a volumetric efficiency that is influenced by dead volumes and leakages:\n\\[\n\\eta_{\\mathrm{v}} = \\frac{\\dot{m}}{\\frac{\\dot{\\mathcal{V}} _{\\mathrm{D}}}{v _{\\mathrm{in}}}}\n\\]\n\neta_v = m_dot_actual/m_dot_ideal*100\nfig2, ax2 = plt.subplots()\n\nax2.plot(T_evap,m_dot_actual,'ko-',label=\"Actual mass flow rate\")\nax2.set_xlabel(\"Evaporating temperature [ºC]\")\nax2.set_ylabel(\"Gas flow rate [kg/h] (dots)\")\n\nax3 = ax2.twinx()\nax3.plot(T_evap,eta_v,'kx--',label=\"Volumetric efficiency\")\nax3.set_ylabel(\"Volumetric efficiency [%] (x)\")\nax2.grid()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nWhat influences the volumetric efficiency?\nThe volumetric efficiency depends primarily on the pressure ratio between condensing and evaporating levels:\n\\[\nr _{\\mathrm{p}} = \\frac{P _{\\mathrm{cond}}}{P _{\\mathrm{evap}}}\n\\]\nSo let’s plot that:\n\neta_v = m_dot_actual/m_dot_ideal\n\nPcond = PropsSI(\"P\",\"T\",df[\"Condensing temperature [C]\"].values[0]+273,\"Q\",1,fluid)\nPevap = np.array([PropsSI(\"P\",\"T\",Te+273,\"Q\",1,fluid) for Te in T_evap])\nrp = Pcond/Pevap\nfig20, ax20 = plt.subplots()\n\n\n\nax20.plot(rp,eta_v,'ko-')\nax20.set_xlabel(\"Pressure ratio\")\nax20.set_ylabel(\"Volumetric efficiency\")\n\nplt.show()\n\n\n\n\n\n\n\n\nMaybe we can use a log-log plot?\n\neta_v = m_dot_actual/m_dot_ideal\n\nPcond = PropsSI(\"P\",\"T\",df[\"Condensing temperature [C]\"].values[0]+273,\"Q\",1,fluid)\nPevap = np.array([PropsSI(\"P\",\"T\",Te+273,\"Q\",1,fluid) for Te in T_evap])\nrp = Pcond/Pevap\nfig20, ax20 = plt.subplots()\n\n\n\nax20.plot(rp,eta_v,'ko-')\nax20.set_xlabel(\"Pressure ratio\")\nax20.set_ylabel(\"Volumetric efficiency\")\nax20.set_yscale('log')\nax20.set_xscale('log')\n\nplt.show()\n\n\n\n\n\n\n\n\nwhich seems to make the relationship linear. A candidate for a model would be then:\n\\[\n\\ln \\eta_{\\mathrm{v}} = b_0 + b_1 \\ln r_{\\mathrm{p}}\n\\]\nAs with yesterday’s post, We will use scikit-learn to train a model to calculate the coefficients, based on 50% of the data selected at random:\n\nfrom sklearn.metrics import r2_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LinearRegression\n\nX = np.log(rp).reshape(-1,1)\nY = np.log(eta_v)\n\nX_train,X_test,Y_train,Y_test = train_test_split(X,Y,test_size=0.5)\n\nmodel = LinearRegression(fit_intercept=False)\nmodel.fit(X_train, Y_train)\n\nfig4, ax4 = plt.subplots()\nax4.plot(np.log(rp),np.log(eta_v),'ko')\nax4.plot(X,model.predict(X),'k-')\nax4.set_xlabel(\"Log of Pressure ratio\")\nax4.set_ylabel(\"Log of Volumetric efficiency\")\nax4.set_title('accuracy (R^2) =  %.5f'\n% r2_score(Y_test, model.predict(X_test)))\nplt.show()\n\n\n\n\n\n\n\n\nThe advantage of using the pressure ratio as the main feature is that the effect of the superheat degree is probably low, but we need more data with the same pressure ratio and different degrees of superheat to be sure."
  },
  {
    "objectID": "post/superheat/index.html#polynomials-for-cooling-capacity",
    "href": "post/superheat/index.html#polynomials-for-cooling-capacity",
    "title": "Including superheat in the compressor regression",
    "section": "Polynomials for cooling capacity",
    "text": "Polynomials for cooling capacity\nThe other useful thing to do with a compressor datasheet of calculating a polynomial of the form [1]:\n\\[\n\\dot{Q} _{\\mathrm{L}} = a _0 + a _1  t _{\\mathrm{evap}} + a _2  t _{\\mathrm{evap}}^2\n\\]\nwhere \\(\\dot{Q}_{\\mathrm{L}}\\) is the cooling capacity and \\(t_{\\mathrm{evap}}\\) is the evaporating temperature in degress Celsius. Four points of note:\n\nThis polynomial allows you to interpolate in different points other than the tabulated ones, an also can be combined with other models in the refrigeration system;\nThe coefficients themselves are function of the condensing temperature, the fluid properties and the compressor geometry;\nThe same thing can be done for the power consumption, with different coefficients;\nThe resulting polynomial is valid for the same compressor in different evaporating pressures, but keeping the superheat and subcooling degress the same as the values from the datasheet.\n\n\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import Pipeline\n\nX = df.values[:,:1] # first column (evaporating temperature) as a 2D array, as required\nYQL = df[\"Cooling Capacity [W]\"].values\n\nX_train,X_test,QL_train,QL_test = train_test_split(X,YQL,test_size=0.5)\n\nQL_quadratic_model = Pipeline(\n[\n('poly', PolynomialFeatures(degree=2)),\n('linear', LinearRegression(fit_intercept=False))])\nQL_quadratic_model.fit(X_train, QL_train)\nQL_quadratic_pred = QL_quadratic_model.predict(X_test)\n\nfig4, ax4 = plt.subplots()\nax4.scatter(QL_test,QL_quadratic_pred)\nax4.grid()\nax4.set_xlabel('Simulated cooling capacity [W]]')\nax4.set_ylabel('Predicted cooling capacity [W]')\nax4.set_title('accuracy (R^2) =  %.5f'\n% r2_score(QL_test, QL_quadratic_pred))\nplt.show()\n\n\n\n\n\n\n\n\nThe resulting coefficients are (from \\(a_0\\) to \\(a_2\\)):\n\nprint(QL_quadratic_model.named_steps[\"linear\"].coef_)\n\n[8.47e+02 3.11e+01 3.40e-01]\n\n\nHence, this polynomial seems to work fine, even though we have very few data points; with more data points in a test apparatus, this same model could be retrained, making the coefficients more and more accurate.\nThe advantage of this approach is that, if we are working with this compressor and selecting heat exchangers sizes, for instance, we do not need to evaluate thermophysical properties at each iteration but only a polynomial, which is a huge time saver. How to make this integration between models is the subject of another post."
  },
  {
    "objectID": "post/superheat/index.html#references",
    "href": "post/superheat/index.html#references",
    "title": "Including superheat in the compressor regression",
    "section": "References",
    "text": "References\n[1]: Stoecker, W. F. Design of thermal systems. [sl]: McGraw-Hill, 1980."
  },
  {
    "objectID": "post/color/index.html",
    "href": "post/color/index.html",
    "title": "Why and how to use different colors in VS Code for different projects",
    "section": "",
    "text": "I know what you are going to say: I’m weird, and apparently it makes no sense to spend time on things like this. But here it is: a post about setting different color schemes for VS Code, depending on which folder is open."
  },
  {
    "objectID": "post/color/index.html#why-setting-different-colors-is-good-for-productivity",
    "href": "post/color/index.html#why-setting-different-colors-is-good-for-productivity",
    "title": "Why and how to use different colors in VS Code for different projects",
    "section": "Why setting different colors is good for productivity",
    "text": "Why setting different colors is good for productivity\nFirst, let us say right away: if you spend some any significant time in a program, making it look more pleasant, so that you’ll want to spend more time with it, is super productive. Plus, hacking things is fun, and fun is always a good way to spend time.\nBut there is also a contextual component. CGP Grey illustrates how it is good to compartimentalize your life, to train your brain to associate certain environments with a desire to focus on certain things:\n{{&lt; youtube snAhsXyO3Ck &gt;}}\nIn this case, when I see a particular color scheme, I will immediately start to think about the project associated with those colors. Also, as I work with different projects alternating them within a given day (sometimes using different programming languages), assigning a different color scheme to each project help me differentiate between them."
  },
  {
    "objectID": "post/color/index.html#how-to-set-and-sync-color-schemes-in-vs-code",
    "href": "post/color/index.html#how-to-set-and-sync-color-schemes-in-vs-code",
    "title": "Why and how to use different colors in VS Code for different projects",
    "section": "How to set and sync color schemes in VS Code",
    "text": "How to set and sync color schemes in VS Code\nWhen you configure the editor’s settings, VS Code saves a JSON file with your customizations in a default location (see the aforelinked docs page). One of the settings is the color scheme. For my default color scheme, I like the Solarized Light theme:\n\n\n\nScreenshot of VS Code in the Solarized Light color scheme\n\n\nNow, how can this setting be changed based on the folder you open? It turns out you can open a particular folder in VS Code, which it calls a workspace (workspaces can actually combine different folders). In the Settings UI, you can set it to customize the workspace settings:\n\n\n\nScreenshot of the VS Code settings editor\n\n\nNow, when you save the settings, a settings.json file is created inside the folder you are in; in the figure below, I’ve setup the “local” color theme to a dark version of the solarized scheme - but this gets loaded only when I open up that particular folder!\n\n\n\nScreenshot of VS Code in the Solarized Dark color scheme"
  },
  {
    "objectID": "post/color/index.html#my-color-schemes",
    "href": "post/color/index.html#my-color-schemes",
    "title": "Why and how to use different colors in VS Code for different projects",
    "section": "My color schemes",
    "text": "My color schemes\nI’ll illustrate with two more projects to get you inspired. When I want to mess around with my dotfiles, I use a grey-ish, very utilitarian-looking color scheme (Atom Dark One):\n\n\n\nScreenshot of VS Code in a gray-like color scheme\n\n\nBut when I work in a project involving the Julia language, which is particularly associated with blue-purple colors (check their website), I configured VS Code with the “Tomorrow Night Blue” theme:\n\n\n\nScreenshot of VS Code in a blue-purple color scheme\n\n\nThis is very productive: I can have multiple VS Code windows (working in Julia while tweaking my dotfiles), and when I Alt-TAB the different colors are immediately apparent.\nPlease do tell me if I’m wasting my time…"
  },
  {
    "objectID": "post/go/index.html",
    "href": "post/go/index.html",
    "title": "Studying Go to get better at Python: reader and writer interfaces",
    "section": "",
    "text": "In my day job, I mainly write Python code, but I dedicate a good amount of time to studying the Go programming language. Here’s one good example that shows why it’s so useful."
  },
  {
    "objectID": "post/go/index.html#the-importance-of-thinking-about-io",
    "href": "post/go/index.html#the-importance-of-thinking-about-io",
    "title": "Studying Go to get better at Python: reader and writer interfaces",
    "section": "The importance of thinking about IO",
    "text": "The importance of thinking about IO\nThe kind of programs I write are command line applications that take some specification file in and produce an output file with simulation results; both input and output files are JSON files. I develop these programs for our clients, but I also use them for our own analysis and research. That means that I’m always writing more and more scripts and that analyze the input and output data our main software consumes. The question: how can I add flexibility to this? How can I choose to save the output JSON object to a file, or to the terminal for some quick checking, or to some in-memory object for testing?\nI’ve never seen this type of discussion in Python literature - in fact, before studying Go books, I rarely though of that problem, and had my programs always read from and write to disk files. This is simple, but make testing more cumbersone (I have to always create and delete temporary files) and inefficient."
  },
  {
    "objectID": "post/go/index.html#studying-go-reader-and-writer-interfaces",
    "href": "post/go/index.html#studying-go-reader-and-writer-interfaces",
    "title": "Studying Go to get better at Python: reader and writer interfaces",
    "section": "Studying Go: reader and writer interfaces",
    "text": "Studying Go: reader and writer interfaces\nBut Go books are full of examples that use Reader and Writer interfaces. Here’s some sample (and incomplete) code from one of the example programs of the excelent Powerful Command Line Applications with Go: a function that takes a filename, open that filename for processing, saves the processed data to a temporary file, and writes the path of that file to a Writer interface out:\nGo\n//main.go\n\nfunc run(filename string, out io.Writer) error {\n  // Read all the data from the input file and check for errors \n  input, err := ioutil.ReadFile(filename)\n  if err != nil {\n    return err \n  }\n  \n  // create a temporary file to store processed data\n  temp, err := ioutil.TempFile(\"\", \"mdp*.html\") \n  if err != nil {\n    return err \n  }\n  \n  // do some processing with input and save to temp\n  // ...\n  \n  // close the file\n  if err := temp.Close(); err != nil { \n    return err\n  }\n  \n  // save the results filename to this out interface for checking\n  // e.g. checking that it contains the right data\n  outName := temp.Name()\n  fmt.Fprintln(out, outName)\n  \n  // ... return some status\n}\n  \nThe details are not important, which is why I skipped many lines. What’s important is this: in a test file, I can create a buffer in which to write the filename:\nGo\n//main_test.go\n\nfunc TestRun(t *testing.T) { \n  var mockStdOut bytes.Buffer\n  if err := run(inputFile, &mockStdOut); err != nil { \n  t.Fatal(err)\n  }\n  \n  // mockStdOut contains the resultsfilename, \n  // which we then store in avariable\n  resultFile := strings.TrimSpace(mockStdOut.String())\n  \n  // and now read that file\n  result, err := ioutil.ReadFile(resultFile)\n  \n  // do some checks with results\n  }\nAnd, in the actual application, I can just use the system stdout:\nGo\n// main.go\n\n// definition of the function run(...) as above\n\nfunc main() {\n  // Parse flags\n  filename := flag.String(\"file\", \"\", \"File to process\") \n  flag.Parse()\n  // If user did not provide input file, show usage\n  if *filename == \"\" { flag.Usage() os.Exit(1)\n  }\n  if err := run(*filename, os.Stdout); err != nil { \n    fmt.Fprintln(os.Stderr, err)\n    os.Exit(1)\n  } \n}\nDid you see what happened? The same function can be passed an internal buffer for testing (no writing files required), or the actual terminal in the final application."
  },
  {
    "objectID": "post/go/index.html#parametrizing-io-in-python",
    "href": "post/go/index.html#parametrizing-io-in-python",
    "title": "Studying Go to get better at Python: reader and writer interfaces",
    "section": "Parametrizing IO in Python",
    "text": "Parametrizing IO in Python\nHow can I reproduce this technique in Python? Here is some sample module that is similar to the example above:\nPython\n\"\"\"main.py - the best simulator ever written.\"\"\"\n\nfrom typing import TextIO\nimport sys\n\ndef run(out: TextIO) -&gt; None:\n    out.write(\"I just did some awesome simulation!\\n\")\n\nif __name__ == \"__main__\":\n    run(sys.stdout)\nIf you run, you get the expected result:\nShellSession\npython main.py\n# I just did some awesome simulation!\nBut for testing, we can use a StringIO object, which acts like the buffer we saw earlier:\nPython\n\"\"\"test_main.py - Check that we are indeed awesome\"\"\"\n\nimport main\nimport io\n\ndef test_main():\n    mock = io.StringIO()\n\n    main.run(mock)\n\n    message = mock.getvalue()\n\n    assert message == \"I just did some awesome simulation!\\n\"\nWhen running this case with pytest (pytest test_main.py, provided why files are in the same directory), the test passes. We did not have to read from stdout, nor save anything to a file, both of which require more code to be written."
  },
  {
    "objectID": "post/go/index.html#studying-go-is-not-a-waste-of-time-even-if-you-do-not-write-go",
    "href": "post/go/index.html#studying-go-is-not-a-waste-of-time-even-if-you-do-not-write-go",
    "title": "Studying Go to get better at Python: reader and writer interfaces",
    "section": "Studying Go is not a waste of time even if you do not write Go",
    "text": "Studying Go is not a waste of time even if you do not write Go\nWhat does this mean in practice? It means you stop writing print() statements all over the place, and think about what is being read and written. This forces me to think of the software at a higher level.\nI think there’s a gap in Python literature: too much focus on new syntax constructions (which are very nice), too focus on Jupyter notebooks, and too little focus in software development: testing, structuring code, making it easier to extend. Both Writing Powerful Command-Line Applications in Go and Writing Interpreters in Go focus on that: writing useful programs, without nitty-picking syntax details.\nWhy my obsession with Go in particular? It’s just that the literature is full of good books, and it’s a modern language with a clean syntax, powerful and easy to learn in incremental steps. Slowly but surely, I’m beginning to write more and more Go programs almost as more powerful shell scripts, because it’s so pleasant to do that. I highly recommend addying this language to your repertoire."
  },
  {
    "objectID": "post/starship/index.html",
    "href": "post/starship/index.html",
    "title": "Higher productivity for developers with Starship",
    "section": "",
    "text": "If you follow the internet trends around tools for developers, you might have heard of Starship, a tool that gives useful information quickly for higher productivity for developers.\nAt first, I got the feeling that Startship is more cosmetic than anything else, but after a few weeks working with it, I noticed that it is indeed a productivity tool in the original sense: low effort, high speed gains in the day-to-day workflow."
  },
  {
    "objectID": "post/starship/index.html#a-typical-problem-that-starship-solves",
    "href": "post/starship/index.html#a-typical-problem-that-starship-solves",
    "title": "Higher productivity for developers with Starship",
    "section": "A typical problem that Starship solves",
    "text": "A typical problem that Starship solves\nBy day, I write mostly Python code, and the tricky thing that people forget is that there is no Python - there are Pythons. Each new Python 3.X version introduces several new features and might break some APIs from other 3.X versions. If I write code for Python 3.12, colleagues of mine that not so tech-savy and have only Python 3.10 in their machines would not be able to use my tools.\nA similar problem occur for package versions: different clients use different versions of my company’s products, so when debugging I need to be sure of running the correct version.\nEnter Starship. When prototyping an application this morning, this is the prompt I got:\nShellSession\n~/newapp on  main [?] is 📦 v0.1.0 via 🐍 v3.11.8 took 4s\n➜\nThis tells me immediately that:\n\nI’m on the newapp root directory\nI’m on the main branch\nThere is at least one untracked file in git\nThe package version 0.1.0\nI’m not in an activated virtual environment, but am running Python 3.11.8\nThe previous command tool 4 seconds to run\n\nEverything substantial that I would do, like activating an environment or bumping up the package version, would reflect immediately in the prompt.\nWhen I switch projects to use Go for a new CLI tool that I’m building, now I see this:\nShellSession\n~/awesome-go-cli on  main via 🐹 v1.21.6\nand now my brain notices the new animal and knows that I need to think statically-typed."
  },
  {
    "objectID": "post/starship/index.html#productivity-for-developers-easy-to-setup-powerful-results",
    "href": "post/starship/index.html#productivity-for-developers-easy-to-setup-powerful-results",
    "title": "Higher productivity for developers with Starship",
    "section": "Productivity for developers: easy to setup, powerful results",
    "text": "Productivity for developers: easy to setup, powerful results\nOf course real nerds would set it up with shell variables in the profile and RC files. The real productivity leap is that configuration is minimal:\n\nInstall Starship with the official guide\nCreate your configuration in ~/.config/starship.toml. Everything you saw above is built-in: there is the entirety of my configuration with comments:\n\nTOML\n\n# Replace the '❯' symbol in the prompt with '➜'\n[character] # The name of the module we are configuring is 'character'\n# The 'success_symbol' segment is being set to '➜' with the color 'bold green'\nsuccess_symbol = '[➜](bold green)'\nerror_symbol = '[➜](bold red)'\n\n\n[c]\nsymbol = \" \"\n\n[directory]\n# the default is to truncate the full path in the prompt\n# this increases the number of subdirectories before truncation happens\nread_only = \" 󰌾\"\ntruncation_length = 6\ntruncation_symbol = \"...\"\ntruncate_to_repo = false\n\n\n[docker_context]\n# I rarely use Docker but when I do, I find the Docker additions distracting\ndisabled = true\nThe TOML file is based on modules that you customize individually. Notice I did not have to change nor the Python nor the Go modules.\nDo you use any shell prompt like this? Leave suggestions for similar productivity tools in the comments!"
  },
  {
    "objectID": "post/monkey/index.html",
    "href": "post/monkey/index.html",
    "title": "Why I’m studying how to write an interpreter in Go… when I’m a Python developer",
    "section": "",
    "text": "I think there is no better way to start this blog about being obsessed with programming: an explanation (mostly for myself) on why I’m studying interpreters (when I do not develop anything related to that) implemented in Go (a language I do not use professionally)."
  },
  {
    "objectID": "post/monkey/index.html#why-this-subject",
    "href": "post/monkey/index.html#why-this-subject",
    "title": "Why I’m studying how to write an interpreter in Go… when I’m a Python developer",
    "section": "Why this subject?",
    "text": "Why this subject?\nThe first time I realized that studying interpreters and compilers is somethink I’d like to do was when re-reading The Pragmatic Programmer last year. I first read this book almost 10 years ago, when I was graduating college and started working more and more with programming, first in my internship and then in my Master’s studies. I remember it “being OK”, without much resonance; however, now that I’m primarily a software developer, I thought it was time for a review.\nThe Pragmatic Programmer starts with a list of tips that are obvious to me: be professional, care about your work, focus on quality, make learning a habit. The first tip that actually sounded as something new and noteworthy (at least for me, someone who doesn’t have a degree in Computer Science or anything related) was the importance of developing your own domain specific languages (DSL): think about common and repetitive tasks you have to do, encode how you would describe them in a dedicated language, and then create a program that will evaluate this language.\nAs it turns out, I do have lots of tasks that could use a specific language. In my daily work, I deal with JSON files that follow a specific configuration (describing inputs and outputs to simulations) that very often trigger the same sort of analysis. A DSL for my line of work would look like this:\nfor results in list_of_results:\n    plot temperature vs position\n    plot pressure vs position\n    calculate maximum pressure\n\nplot maximum pressure of each result vs initial pressure of each result\nThis actually would be useful! In addition, those very JSON files need to be parsed and validated - they also need to be interpreted in a way."
  },
  {
    "objectID": "post/monkey/index.html#the-book",
    "href": "post/monkey/index.html#the-book",
    "title": "Why I’m studying how to write an interpreter in Go… when I’m a Python developer",
    "section": "The book",
    "text": "The book\nIn the beginning of this year, then, I decided to give Writing an Interpreter in Go a try, inspired by this video (which made me also learn OCaml just because, but that’s a story for another time).\nhttps://www.youtube.com/watch?v=NjKJ9-ejR6o\nI’m still on the second chapter, but I’m loving it. The book is well written, didactic without assuming the reader is stupid. It doesn’t require the reader know a lot of Go, and it doesn’t waste time explaning the syntax either - I can always just look it up.\nThis is a book for software developers, and the author assumes software developer can learn details of programming languages. Most importantly, it’s a book about software development: thinking about data structures, developing incremental tests for their behaviour, not being afraid of creating functions that have just one line of code if they make understanding the program much easier, organizing the code into separate modules. All of these are useful things that I always to improve in my job."
  },
  {
    "objectID": "post/monkey/index.html#what-im-applying-in-my-daily-work-as-a-python-developer",
    "href": "post/monkey/index.html#what-im-applying-in-my-daily-work-as-a-python-developer",
    "title": "Why I’m studying how to write an interpreter in Go… when I’m a Python developer",
    "section": "What I’m applying in my daily work as a Python developer",
    "text": "What I’m applying in my daily work as a Python developer\nMy main project at work is a simulator that was originally written by another very talented engineer, and that I now have to maintain and extend. Very often we and our clients deal with problems when reading and parsing the input files: some fields are missing or they are too complex. Inspired by these studies, I’m becoming less and less afraid of creating small data structures and functions that process one small part at a time - instead of just trying to conform to what is already in the code.\nYes, I develop Python application, but the language is just a detail. The book could be re-written in Python and the ideas, the theory, the methods would be the same. If I re-implemented my main project in Go (which I actually dream of, to get all the static cross-compilation benefits), my clients couldn’t care less - they want simulation results. I’m a firmly believer of being programming languages polyglot and being able to study books that show code in different languages.\nI’ll have more to say when I advance in the book and use more and more of its ideas in my Python projects. In the meanwhile, give Writing an Interpreter in Go… a go."
  },
  {
    "objectID": "post/pyright/index.html",
    "href": "post/pyright/index.html",
    "title": "How to make Neovim Python LSP aware of your Hatch environments",
    "section": "",
    "text": "If you are a nerd like me, you probably have joined the Neovim cult and have spent more hours configuring it than you care to admit.\nThen you might also have spent digging around Python project managers and settled on using Hatch for one of your projects. In principle, this means you do not have to manually create environments. You define dependencies in pyproject.toml and, when executing Hatch scripts, the hatch program will create environments, install dependencies and execute the commands (like running tests, linting, formatting etc) inside those environments.\nBut now, when you write Python code on Neovim, using the standard pyright as the language server (I use the Python-ruff pack from the AstroNvim communtity), if you use the same packages you define in the dependencies section (and which are not installed in your global Python environment), pright will complain that it cannot find packages:\n\n\n\nScreenshot of a neovim session showing error messages\n\n\nHow can it not find packages when you declared everything in the pyproject.toml file, and everything is supposed to be downloaded and installed automatically?"
  },
  {
    "objectID": "post/pyright/index.html#the-problem",
    "href": "post/pyright/index.html#the-problem",
    "title": "How to make Neovim Python LSP aware of your Hatch environments",
    "section": "",
    "text": "If you are a nerd like me, you probably have joined the Neovim cult and have spent more hours configuring it than you care to admit.\nThen you might also have spent digging around Python project managers and settled on using Hatch for one of your projects. In principle, this means you do not have to manually create environments. You define dependencies in pyproject.toml and, when executing Hatch scripts, the hatch program will create environments, install dependencies and execute the commands (like running tests, linting, formatting etc) inside those environments.\nBut now, when you write Python code on Neovim, using the standard pyright as the language server (I use the Python-ruff pack from the AstroNvim communtity), if you use the same packages you define in the dependencies section (and which are not installed in your global Python environment), pright will complain that it cannot find packages:\n\n\n\nScreenshot of a neovim session showing error messages\n\n\nHow can it not find packages when you declared everything in the pyproject.toml file, and everything is supposed to be downloaded and installed automatically?"
  },
  {
    "objectID": "post/pyright/index.html#the-solution",
    "href": "post/pyright/index.html#the-solution",
    "title": "How to make Neovim Python LSP aware of your Hatch environments",
    "section": "The solution",
    "text": "The solution\nYou need to tell pyright where to find environments in which the packages are installed; then, pyright will recognized installed Python packages as something you can import from. In other words: pyright needs to be aware of your Hatch environments.\nIt might help to first configure hatch itself to use a directory for the virtual environments that are easy to find. I like to use a .hatch subfolder in my project root folder (don’t forget to exclude it from source control). You can change the global hatch configuration to always use that location when using the hatch command with this shell commands:\nShellSession\nhatch env prune # delete previously created environments\nhatch config set dirs.env.virtual \".hatch\" # modify configuration\nNow, when you run a hatch command, it will create environments under .hatch.\nNow you have to configure pyright in your pyproject.toml file. Suppose you define a dev environment in which to run various checks like this:\nTOML\n# pyproject.toml\n\n[tool.hatch.envs.dev]\npython = \"3.11\"\n\ndependencies = [\"mypy&gt;=1.0.0\", \"pytest\", \"ruff\"]\n\n[tool.hatch.envs.dev.scripts]\ncheck = [\n  \"pytest -xvv --ff\",\n  \"ruff format .\",\n  \"ruff check .\",\n]\nThis way, you can also create a environment, install your package and run all tests with:\nShellSession\nhatch run dev:check\nNow, include the following configuration:\nTOML\n# pyproject.toml\n\n[tool.pyright]\nexecutionEnvironments = [{ root = \"src\" }]\nvenvPath = \".hatch\"\nvenv = \"dev\"\nRestart your neovim, and you will see that the messages above disappear: pyright will get all package information from &lt;your project folder&gt;/.hatch/dev/. As a bonus, you can import pytest in the test files to add fixtures and other goodies.\nI hope this is helpful! Let me know if you want to learn more about Hatch or Neovim."
  },
  {
    "objectID": "post/interpreters/index.html",
    "href": "post/interpreters/index.html",
    "title": "Software Development Book Review: Writing Interpreters in Go",
    "section": "",
    "text": "A couple of weeks ago, I mentioned Writing Interpreters in Go, a book that teaches you to write an interpreters for the Monkey programming language. If you write software for a living, you should study this book. This is a software development book more than an interpreters book that has much to teach."
  },
  {
    "objectID": "post/interpreters/index.html#an-overview-of-the-book",
    "href": "post/interpreters/index.html#an-overview-of-the-book",
    "title": "Software Development Book Review: Writing Interpreters in Go",
    "section": "An overview of the book",
    "text": "An overview of the book\nWriting Interpreters in Go is incredibly well written. The structure is sound, with medium-sized chapters, each one of them focusing on one major task of an interpreter:\n\nLexing, reading a program as a string and making sense of each character to produce tokens. For instance: “if the current character, than all numbers up to the next whitespace is an integer”;\nParsing, where you combine tokens into an abstract syntax tree (the famous AST)\nEvaluating, where you use the host language (in this case, Go) to convert a “Infix Plus operation a+b” from the AST into an actual instruction a+b.\n\nThere are also chapters on extending the language from the initial implementation and on defining macros (this is really advanced stuff)."
  },
  {
    "objectID": "post/interpreters/index.html#differences-between-programming-books-and-software-development-books",
    "href": "post/interpreters/index.html#differences-between-programming-books-and-software-development-books",
    "title": "Software Development Book Review: Writing Interpreters in Go",
    "section": "Differences between programming books and software development books",
    "text": "Differences between programming books and software development books\nI’m at a stage in my carrer that I do not need to programming books, I need software development books. I consider the Go syntax actually quite simple, and appraise the author Thorsten Ball for not wasting time on that. He focuses on the much important issues of program organization, like creating separate modules for each major task. He create modules for the business logic, goes one level up to define a loop that reads input and applies that logic (parametrizing the I/O), and then create a main module to present this loop to the screen.\nI also like how he defines tests very carefully, and is not afraid of testing edge cases. Is it just me, or that are too many testing tutorials with assert 1 + 1 == 2?"
  },
  {
    "objectID": "post/interpreters/index.html#key-takeaways-from-the-book",
    "href": "post/interpreters/index.html#key-takeaways-from-the-book",
    "title": "Software Development Book Review: Writing Interpreters in Go",
    "section": "Key takeaways from the book",
    "text": "Key takeaways from the book\n\nWhen thinking about a concept, start by creating small data structures, like structs, enums or classes. Codify in the program what’s on your head;\nWrite tests to define what you want from those data structures, and use the same inputs as the user. If your program takes a filename as an input, then the test should get the filename as an input. This tells you how hard is to actually use your program;\nDon’t be afraid of going to the old-fashioned literature of papers and books. The major algorithm from Writing Interpreters in Go, a modern book about a modern language, comes from a paper from the 70s.\n\nHave you read this book? What do you think?"
  },
  {
    "objectID": "portfolio.html",
    "href": "portfolio.html",
    "title": "My Portfolio of Programming Projects",
    "section": "",
    "text": "I’m currently employed as a Mechanical/Research Engineer in a research group in southern Brazil, and my main responsibility is developing applications and libraries for use of one of Brazil’s largest oil & gas software. Our main products is a wellbore simulator and a thermophysical properties library. Both are used by end users in a web app (that is developed by a third-party).\nMy main working language in this position is Python, mainly for faciliting collaborating with other engineers, researchers, and especially students. I’ve been using Python since 2011 and I consider myself very profficient in it, in particular with the scientific stack: NumPy, SciPy, and Matplotlib. I’m also very familiar developing command line applications with Typer and Rich, managing projects with tox and hatch, and testing with pytest.\nMy main projects are private, but some work-related open-source projects include:\n\nscientific-python2.7-docker: a Docker image with Python 2.7 and scientific libraries installed on top of it (our properties library is implemented in Python 2.7 for use in a legacy server)\ntissues: a helper utility that runs a linter of your choice, and then fails not if there is an issue, but if the number of issues has not decreased from the previous run. This is useful for forcing yourself to incrementally improve a legacy codebase, where eliminating all linter issues in one take is not viable"
  },
  {
    "objectID": "portfolio.html#current-job",
    "href": "portfolio.html#current-job",
    "title": "My Portfolio of Programming Projects",
    "section": "",
    "text": "I’m currently employed as a Mechanical/Research Engineer in a research group in southern Brazil, and my main responsibility is developing applications and libraries for use of one of Brazil’s largest oil & gas software. Our main products is a wellbore simulator and a thermophysical properties library. Both are used by end users in a web app (that is developed by a third-party).\nMy main working language in this position is Python, mainly for faciliting collaborating with other engineers, researchers, and especially students. I’ve been using Python since 2011 and I consider myself very profficient in it, in particular with the scientific stack: NumPy, SciPy, and Matplotlib. I’m also very familiar developing command line applications with Typer and Rich, managing projects with tox and hatch, and testing with pytest.\nMy main projects are private, but some work-related open-source projects include:\n\nscientific-python2.7-docker: a Docker image with Python 2.7 and scientific libraries installed on top of it (our properties library is implemented in Python 2.7 for use in a legacy server)\ntissues: a helper utility that runs a linter of your choice, and then fails not if there is an issue, but if the number of issues has not decreased from the previous run. This is useful for forcing yourself to incrementally improve a legacy codebase, where eliminating all linter issues in one take is not viable"
  },
  {
    "objectID": "portfolio.html#side-projects",
    "href": "portfolio.html#side-projects",
    "title": "My Portfolio of Programming Projects",
    "section": "Side Projects",
    "text": "Side Projects\nI love learning new languages and I’ve been making a point of creating some projects to showcase what I’ve learned. Since my expertise is in scientific- and text-oriented command-line applications, my latest interests are Rust and Go.\nSome of my non-Python projects:\n\nbln - a simplified version of the Unix ln command, written in Go, and that uses flags instead of arguments (I can never remember the order of arguments in ln).\nengsymbols - a LaTeX package to facilitate writing complex engineering symbols\n\nSee also my dotfiles and my neovim configuration."
  },
  {
    "objectID": "portfolio.html#open-source-contributions",
    "href": "portfolio.html#open-source-contributions",
    "title": "My Portfolio of Programming Projects",
    "section": "Open-source contributions",
    "text": "Open-source contributions\nI’m learning how to better contribute to open-source projects. Some projects that I’ve contributed in the past are:\n\nprm -a Bash project manager\nDrWatson - a Julia scientific project manager"
  },
  {
    "objectID": "post/compressibility/index.html",
    "href": "post/compressibility/index.html",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "",
    "text": "One of my disappointments back when I was teaching is that I never taught a Thermodynamics class. I heard it is a terrible subject to teach, with high failing rates, but I’d like to have that experience nevertheless.\nSpeaking as someone who studied Thermodynamics as an undergrad student and then during graduate school, and who taught classes that depended on Thermodynamics, I think there is a big specific problem with these courses: students have this subject too early in the curriculum, without the maturity to proper understand the difficult concepts. Also, it becomes too easy to forget what you saw in a Thermodynamics class 15 years ago."
  },
  {
    "objectID": "post/compressibility/index.html#expansion-coefficients",
    "href": "post/compressibility/index.html#expansion-coefficients",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "Expansion coefficients",
    "text": "Expansion coefficients\nI’m telling this story from personal experience: I’m working on a project where I have to deal with two “expansion coefficients” that all substances have – how they expand (or contract) upon receiving energy – , but that do not appear often in most thermodynamic analyses. Hence, I had to go back to the textbooks to understand them.\nI’m taking the definitions below from [1]. The first coefficient is the volumetric isobaric expansivity, which measured how the volume of a substance changes you heat it up at constant pressure:\n\\[\n\\beta = \\frac{1}{v}\\left(\\frac{\\partial v}{\\partial T}\\right)_p\n\\]\nwhere \\(v\\) is the specific volume, \\(p\\) is the pressure and \\(T\\) the absolute temperature. This coefficient has units of K\\(^{-1}\\), and can be negative; famously, liquid water expands when cooled down below 4 ºC (this is why water bottles can break in the freezer). Most substances, however, expand when heated up (\\(\\beta &gt; 0\\)).\nThe volumetric expansivity may be familiar to Heat Transfer students, and it appears in Free Convection theory; fluids with large values of \\(\\beta\\) change density substantially and then move around quickly when temperature gradients are present.\nThe other coefficient is the isothermal compressibility:\n\\[\n\\alpha = -v \\left(\\frac{\\partial v}{\\partial p}\\right)_T\n\\]\nThis coefficient, with units of Pa\\(^{-1}\\) can never be negative: if you exert force in a piston with some fluid at constant temperature, it will contract."
  },
  {
    "objectID": "post/compressibility/index.html#calculating-expansivity-and-compressibility-with-coolprop",
    "href": "post/compressibility/index.html#calculating-expansivity-and-compressibility-with-coolprop",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "Calculating expansivity and compressibility with CoolProp",
    "text": "Calculating expansivity and compressibility with CoolProp\nBeware that the coefficients above have many names, depending on the source you are using. To calculate them using the CoolProp library in Python, for instance, I had to look up the available functions.\nNotice that, as derivatives of \\(p-v-T\\) relations, \\(\\alpha\\) and \\(\\beta\\) are properties of state, depending on two other properties to be calculated. For instance, the expansivity of air at atmospheric pressure and ambient temperature is:\n\nfrom CoolProp.CoolProp import PropsSI\nT0 = 298 # K\nP0 = 101.325e3 # Pa\nfluid = 'Air'\nbeta = PropsSI(\"ISOBARIC_EXPANSION_COEFFICIENT\",\"T\",T0,\"P\",P0,fluid)\nprint(\"%.3e K^-1\" %(beta,))\n\n3.365e-03 K^-1\n\n\nAnd the compressibility can be calculated as:\n\nalpha = PropsSI(\"ISOTHERMAL_COMPRESSIBILITY\",\"T\",T0,\"P\",P0,fluid)\nprint(\"%.3e Pa^-1\" %(alpha,))\n\n9.872e-06 Pa^-1"
  },
  {
    "objectID": "post/compressibility/index.html#relationship-to-specific-heat",
    "href": "post/compressibility/index.html#relationship-to-specific-heat",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "Relationship to specific heat",
    "text": "Relationship to specific heat\nThe Mayer relation is [1]:\n\\[\nc_p - c_v = \\frac{vT\\beta^2}{\\alpha}\n\\]\nwhere \\(c_p\\) and \\(c_v\\) are respectively the constant-pressure and constant-volume speficic heats. The right hand side is always non-negative, which enforces \\(c_p \\ge c_v\\). The equality sign applies from incompressible substances, for which \\(\\beta = 0\\).\nLet us verify that relation:\n\nc_p = PropsSI(\"CPMASS\",\"T\",T0,\"P\",P0,fluid)\nc_v = PropsSI(\"CVMASS\",\"T\",T0,\"P\",P0,fluid)\nv = 1/PropsSI(\"D\",\"T\",T0,\"P\",P0,fluid)\nprint(c_p - c_v - v*T0*beta**2/alpha)\n\n0.0\n\n\n\nAn aside about how these properties are calculated\nEngineers should beware of black boxes. In the examples above (and below), what exactly is CoolProp doing?\nIf you are doing a serious project involving thermodynamic and transport properties, you should definitely check out the CoolProp documentation on fluid properties\nAs explained before, \\(\\alpha\\) and \\(\\beta\\) can be calculated with only knowledge of the equation of state (EOS). Specific heats cannot be calculated from an EOS; additional information about the energy of the fluid is needed [2], usually from empirical correlations. What the Mayer relation enforces is that only the difference between specific heats can be determined from an EOS; but if you also have a model for \\(c_p\\), you can calculate \\(c_v\\) and vice-versa. You don’t need two different models for the two specific heats.\nCheck out the CoolProp documentation page above to see what other information, besides the EOS, is needed to build up the CoolProp database."
  },
  {
    "objectID": "post/compressibility/index.html#comparison-between-gases",
    "href": "post/compressibility/index.html#comparison-between-gases",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "Comparison between gases",
    "text": "Comparison between gases\nIf we pick only gases commonly present in mechanical engineering applications, how do the values of \\(\\alpha\\) and \\(\\beta\\) vary between them?\nWhen doing this sort of analysis, I always find it useful to use pandas to build a table and work from there:\n\nfrom pandas import Series, DataFrame\nimport numpy as np\n\ngases = [\n  \"Air\",\n  \"Argon\",\n  \"CarbonDioxide\",\n  \"Ethane\",\n  \"Helium\",\n  \"IsoButane\",\n  \"Nitrogen\",\n  \"Methane\"]\n  \nalphav = np.empty_like(gases,dtype='float')\nbetav = np.empty_like(gases,dtype='float')\n\nfor i,gas in enumerate(gases):\n  alphav[i] = PropsSI(\"ISOTHERMAL_COMPRESSIBILITY\",\"T\",T0,\"P\",P0,gas)\n  betav[i] = PropsSI(\"ISOBARIC_EXPANSION_COEFFICIENT\",\"T\",T0,\"P\",P0,gas)\n\ndf = DataFrame(\n  {\n    \"Gas\": gases,\n    \"alpha [MPa^-1]\": 1e6*alphav,\n    \"beta [K-1]\": betav\n}\n)\nprint(df)\n\n             Gas  alpha [MPa^-1]  beta [K-1]\n0            Air        9.872466    0.003365\n1          Argon        9.875500    0.003366\n2  CarbonDioxide        9.919539    0.003412\n3         Ethane        9.945354    0.003435\n4         Helium        9.864455    0.003354\n5      IsoButane       10.145642    0.003660\n6       Nitrogen        9.871181    0.003364\n7        Methane        9.886582    0.003377\n\n\nFrankly, this result, with this low variation between gases, surprises me. Mind you that CoolProp is not just using Ideal Gas relations (otherwise the compressibility and expandability of the gases would be equal - prove it!), but is actually using experimental \\(p-v-T\\) data. It just so happens that there is not a wide variation between gases."
  },
  {
    "objectID": "post/compressibility/index.html#final-remarks",
    "href": "post/compressibility/index.html#final-remarks",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "Final remarks",
    "text": "Final remarks\nI’ve written this post because I needed to learn more about these properties, and I hope it will help more people. Please share it if you find it useful!"
  },
  {
    "objectID": "post/compressibility/index.html#references",
    "href": "post/compressibility/index.html#references",
    "title": "Compressibility and Expandability: what are they and how to calculate",
    "section": "References",
    "text": "References\n[1]: Çengel, Y. A., & Boles, M. A. Termodinâmica (7 ed.). Porto Alegre: AMGH, 2013.\n[2]: Callen, H. B. Thermodynamics and an Introduction to Thermostatistics (2nd ed.). John Wiley and Sons, 1985."
  }
]
{
  "hash": "d4f3d40a9e8ce558e3376dc9788fea7e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Exploring and regressing data from a compressor datasheet with Python\nauthor: Fábio P. Fortkamp\ndate: '2022-04-19'\nslug: compressor\ncategories:\n  - Articles\ntags:\n  - compressors\n  - regression\n  - machine learning\n  - python\n  - scikit-learn\n  - refrigeration\n  - pandas\n  - data science\n---\n\nWhen selecting a compressor for a refrigeration system, the engineer usually has to browse through datasheets to select the most appropriate machine. The user must select a compressor that works with the selected *refrigerant* (chosen for environmental and cost reasons) and is able to deliver the required *cooling capacity* when operating between *evaporating and condensing temperatures*; these are linked to the *cold and hot source temperatures* (that is, the low temperature that is to maintained and the hot ambient temperature over which we have no control) through heat exchangers, but for this text we will ignore that and assume ideal heat exchangers.\n\n[Here is one example of a compressor datasheet](https://products.embraco.com/commtrol/api/pdf/compressor/datasheet/7187?&condensing_temperature=54.4&evaporating_temperature=-23.3&units=w&units_temp=metric-system&filters%5Bbare%5D=513701421&filters%5Brefrigerant%5D%5B%5D=R-600a&filters%5Bstandard%5D=ASHRAE&filters%5Bfrequency%5D=60) that we will explore in this post. The main data is presented in tables of various metrics as a function of evaporating temperature, and we have one table for each condensing temperature like this:\n\n\n{{< figure src=\"datasheet.png\" >}}\n\n\n\nThis must be converted to a text format. After a [recomendation from Dr. Drang](https://leancrew.com/all-this/2021/07/trains-and-tables/?msclkid=2560a0cdbff511ec83dccfa21dafa949?), I often use [Tabula](https://tabula.technology/): this app allows you to upload PDFs and extract a text table from it:\n\n\n{{< figure src=\"tabula.png\" >}}\n\n\n\nThe result can be downloaded as a CSV and cleaned up; it is also useful to explicitly include the condensing temperature as a column, in the case we want to generalize the results of this post to other temperatures:\n\n\n{{< figure src=\"csv.png\" >}}\n\n\n\nThis can be parsed with [pandas](https://pandas.pydata.org/?msclkid=29caa245bff611ec80ba73d4aced3042):\n\n::: {#71e236b9 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf = pd.read_csv(\"compressor.csv\",delimiter=',')\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Evaporating Temperature [C]  Condensing temperature [C]  \\\n0                          -35                          35   \n1                          -30                          35   \n2                          -25                          35   \n3                          -20                          35   \n4                          -15                          35   \n5                          -10                          35   \n\n   Cooling Capacity [W]  Power [W]  Current [A]  Gas Flow Rate [kg/h]  \\\n0                   167        129         1.21                  1.79   \n1                   218        144         1.23                  2.34   \n2                   282        160         1.27                  3.03   \n3                   362        177         1.32                  3.89   \n4                   457        197         1.38                  4.93   \n5                   570        217         1.45                  6.16   \n\n    Efficiency [W/W]  \n0               1.29  \n1               1.52  \n2               1.77  \n3               2.04  \n4               2.33  \n5               2.63  \n```\n:::\n:::\n\n\n## How to calculate the mass flow rate of a compressor?\n\nA reciprocating compressor like this one is a *volumetric* machine: it displaces a certain volume of fluid, based on its internal geometry, and the mass flow rate depends on the suction state.\n\nThe most basic, **ideal** model is then:\n\n$$\n\\dot{m} = \\frac{\\dot{\\mathcal{V}} _{\\mathrm{D}}}{v _{\\mathrm{in}}}\n$$\n\nwhere the numerator is the displacement rate; for a compressor with $z$ cylinders at a fixed rotation speed $n$ it can be calculated\n\n$$\n\\dot{\\mathcal{V}} _{\\mathrm{D}} = {\\mathcal{V}} _{\\mathrm{D}} n z\n$$\n\nwhere $\\mathcal{V} _{\\mathrm{D}}$ is the internal displacement.\n\nLet's plot the actual mass flow rate from the datasheet (using the geometric parameters from it) and the above model to compare:\n\n::: {#3426075e .cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nfrom CoolProp.CoolProp import PropsSI\nimport numpy as np\n\nplt.rc('font', size=14)\n\nVd = 13.54e-6 # in m3\nn = 60 #Hz\nz = 1\nfluid = 'R600a'\n\nVd_dot = Vd * n * z # m3/s\nT_evap = df[\"Evaporating Temperature [C]\"].values\nm_dot_actual = df[\"Gas Flow Rate [kg/h]\"].values\n\n# we take the inverse of the density \n# of saturated vapor (quality = 1)\n# at each value of evaporating temperature\n# not forgetting to convert to K for CoolProp\nv_in = np.array([(1.0/PropsSI(\"D\",\"T\",Te + 273,\"Q\",1,fluid)) for Te in T_evap])\nm_dot_ideal = 3600*Vd_dot/v_in\n\nfig, ax = plt.subplots()\nax.plot(T_evap,m_dot_ideal,'k-',label=\"Ideal\")\nax.plot(T_evap,m_dot_actual,'ko',label=\"Actual\")\nax.set_xlabel(\"Evaporating temperature [ºC]\")\nax.set_ylabel(\"Gas flow rate [kg/h]\")\nax.set_title(\n\"\"\"R-600a compressor, 60 Hz, 1 cylinder, displacement = %.2f cm3, \ncondensing temperature = %d ºC\"\"\" %(Vd*1e6, df[\"Condensing temperature [C]\"].values[0]),\nloc='left')\nax.legend()\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=817 height=490}\n:::\n:::\n\n\nClearly our model is not good enough! There is a *volumetric efficiency* that is influenced by dead volumes and leakages:\n\n$$\n\\eta_{\\mathrm{v}} = \\frac{\\dot{m}}{\\frac{\\dot{\\mathcal{V}} _{\\mathrm{D}}}{v _{\\mathrm{in}}}}\n$$:\n\n::: {#2f5ca3cf .cell execution_count=3}\n``` {.python .cell-code}\neta_v = m_dot_actual/m_dot_ideal*100\nfig2, ax2 = plt.subplots()\n\nax2.plot(T_evap,m_dot_actual,'ko',label=\"Actual mass flow rate\")\nax2.set_xlabel(\"Evaporating temperature [ºC]\")\nax2.set_ylabel(\"Gas flow rate [kg/h] (dots)\")\nax2.set_title(\n\"\"\"R-600a compressor, 60 Hz, 1 cylinder, displacement = %.2f cm3, \ncondensing temperature = %d ºC\"\"\" %(Vd*1e6, df[\"Condensing temperature [C]\"].values[0]),\nloc='left')\n\nax3 = ax2.twinx()\nax3.plot(T_evap,eta_v,'kx',label=\"Volumetric efficiency\")\nax3.set_ylabel(\"Volumetric efficiency [%%] (x)\")\nax2.grid()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){width=817 height=490}\n:::\n:::\n\n\n## Polynomials for cooling capacity\n\nThe other useful thing to do with a compressor datasheet of calculating a polynomial of the form [1]:\n\n$$\n\\dot{Q} _{\\mathrm{L}} = a _0 + a _1  t _{\\mathrm{evap}} + a _2  t _{\\mathrm{evap}}^2\n$$\n\nwhere $\\dot{Q}_{\\mathrm{L}}$ is the cooling capacity and $t_{\\mathrm{evap}}$ is the evaporating temperature in degress Celsius. Three points of note:\n\n1. This polynomial allows you to interpolate in different points other than the tabulated ones, an also can be combined with other models in the refrigeration system;\n2. The coefficients themselves are function of the condensing temperature, the fluid properties and the compressor geometry;\n3. The same thing can be done for the power consumption, with different coefficients.\n\nWe will use [scikit-learn](https://scikit-learn.org/stable/index.html) to *train* a model to calculate the coefficients, based on 50% of the data selected at random:\n\n::: {#f5453ff8 .cell execution_count=4}\n``` {.python .cell-code}\nfrom sklearn.metrics import mean_squared_error, r2_score\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.pipeline import Pipeline\n\nX = df.values[:,:1] # first column (evaporating temperature) as a 2D array, as required\nYQL = df[\"Cooling Capacity [W]\"].values\n\nX_train,X_test,QL_train,QL_test = train_test_split(X,YQL,test_size=0.5)\n\nQL_quadratic_model = Pipeline(\n[\n('poly', PolynomialFeatures(degree=2)),\n('linear', LinearRegression(fit_intercept=False))])\nQL_quadratic_model.fit(X_train, QL_train)\nQL_quadratic_pred = QL_quadratic_model.predict(X_test)\n\nfig4, ax4 = plt.subplots()\nax4.scatter(QL_test,QL_quadratic_pred)\nax4.grid()\nax4.set_xlabel('Simulated cooling capacity [W]]')\nax4.set_ylabel('Predicted cooling capacity [W]')\nax4.set_title('accuracy (R^2) =  %.5f'\n% r2_score(QL_test, QL_quadratic_pred))\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=609 height=465}\n:::\n:::\n\n\nThe resulting coefficients are (from $a_0$ to $a_2$):\n\n::: {#2530c6a5 .cell execution_count=5}\n``` {.python .cell-code}\nprint(QL_quadratic_model.named_steps[\"linear\"].coef_)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[8.34000000e+02 2.97333333e+01 3.06666667e-01]\n```\n:::\n:::\n\n\nHence, this polynomial seems to work fine, even though we have very few data points; with more data points in a test apparatus, this same model could be retrained, making the coefficients more and more accurate. \n\nThe advantage of this approach is that, if we are working with this compressor and selecting heat exchangers sizes, for instance, we do not need to evaluate thermophysical properties at each iteration but only a polynomial, which is a huge time saver. How to make this integration between models is the subject of another post.\n\n\n**UPDATE**: there's a [follow-up post](https://fpfortkamp.com/post/superheat/) which corrects some mistakes that you should read now.\n\n## References\n\n[1]: Stoecker, W. F. Design of thermal systems. [sl]: McGraw-Hill, 1980.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}